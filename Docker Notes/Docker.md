# <span style="color:#f79f1b"> Docker 

- Docker is an open-source platform that 
    - automates the deployment, 
    - scaling
    - management of applications using containerization. 
- Containers are <span style="color:yellow"> lightweight, portable, and self-sufficient </span> units that package an application 
- and its dependencies together, allowing it to run consistently across different computing environments.


## Key Concepts

![img.png](img.png)

- **<span style="color:red"> Container</span>**: A standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another.


- **<span style="color:red"> Image </span>**: A lightweight, standalone, executable package that includes everything needed to run a piece of software, including the code, runtime, libraries, environment variables, and configuration files.


- **<span style="color:red"> Dockerfile**: A text file that contains a series of instructions on how to build a Docker image.


- **<span style="color:red"> Docker Hub**: A cloud-based registry service that allows you to store and share Docker images.


- **<span style="color:red"> Volume**: A mechanism for persisting data generated by and used by Docker containers.


- **<span style="color:red"> Network**: A way to connect Docker containers to each other and to the outside world.




# <span style="color:#3bfb2b"> How To Write Docker File </span>

- A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. 
- Using docker build users can create an automated build that executes several command-line instructions in succession.

- if I want to create a docker file for the Spring Boot Application then the docker file will look like below 

- Use to prefer YT video

```dockerfile
# Use an official OpenJDK runtime as a parent image
FROM openjdk:11-jre-slim
# Set the working directory in the container
WORKDIR /app
# Copy the executable JAR file into the container at /app
COPY target/my-spring-boot-app.jar app.jar    
# Make port 8080 available to the world outside this container
EXPOSE 8080
# Run the JAR file
ENTRYPOINT ["java","-jar","app.jar"]
```

### Now how to run the Docker File

- To build and run the Dockerfile, follow these steps:
- 1. Open a terminal and navigate to the directory containing your Dockerfile.
  1. Build the Docker image using the following command:
     ```bash
     docker build -t my-spring-boot-app .
     ```
  2. Run a container from the image using the following command:
     ```bash
     docker run -p 8080:8080 my-spring-boot-app
     ```
     - This command maps port 8080 of the container to port 8080 on your host machine, allowing you to access the Spring Boot application via `http://localhost:8080`.
     - Make sure to replace `my-spring-boot-app` with the name you used when building the image if it's different.
     - You can stop the container by pressing `Ctrl + C` in the terminal where the container is running or by using the `docker stop` command followed by the container ID or name.
     - That's it! Your Spring Boot application should now be running inside a Docker container.


# <span style="color:#37b8cc"> Useful Docker Commands </span>

- Here are some useful Docker commands that can help you manage Docker containers, images, and other resources:
- 1. **docker build**: Build a Docker image from a Dockerfile.
   ```bash
   docker build -t image_name .
   ```
- 2. **docker run**: Run a Docker container from an image.
   ```bash
   docker run -d -p host_port:container_port image_name
   ```
- 3. **docker ps**: List running Docker containers.
   ```bash
   docker ps
   ```
- 4. **docker ps -a**: List all Docker containers (running and stopped).
   ```bash
   docker ps -a
   ```
- 5. **docker stop**: Stop a running Docker container.
   ```bash
   docker stop container_id
   ```
- 6. **docker rm**: Remove a stopped Docker container.
   ```bash
   docker rm container_id
   ```
- 7. **docker rmi**: Remove a Docker image.
   ```bash
   docker rmi image_name
   ```
- 8. **docker images**: List all Docker images on your system.
   ```bash
   docker images
   ```
- 9. **docker logs**: View the logs of a Docker container.
   ```bash
   docker logs container_id
   ```
- 10. **docker exec**: Run a command inside a running Docker container.
    ```bash
    docker exec -it container_id bash
    ```
  - 11. **docker pull**: Download a Docker image from a registry (e.g., Docker Hub).
      ```bash
      docker pull image_name
      ```  


# <span style="color:#ff6f61"> Docker Networking </span>

- Docker networking allows containers to communicate with each other and with the outside world.
  - Docker provides several built-in network drivers, including:    

![img_1.png](img_1.png)

- Allows **<span style="color:#f71b94">independent containers** to communicate on the same host.

## Types of Docker Networks

### 1. Host Network

- Both the computer and docker container have same port number
- Example: If the host machine has a web server running on port 80, and a Docker container is started with the host network mode, the container can also access the web server on port 80 without any port mapping.

### 2. Bridge Network (Default)

- The bridge between the host and docker container
- Isolated network created by Docker on the host machine.

### 3. User -Defined Bridge Network

- Custom bridge networks created by users for better control over container communication.

### 4. None Network

- Containers have no network connectivity.
- it is completely isolated from any network.
- No, any internet access also

-------------------
- advanced networking options (Docker Swarm )

### 5. MACVLAN Network (Docker Swarm )

- Generally, it communicates with MAC address.
- Assigns a MAC address to a container, making it appear as a physical device on the network.
- Useful for legacy applications that require direct access to the physical network.

### 6. Overlay Network (Docker Swarm )
### 7. IPvlan Network (Docker Swarm )


-------------

# <span style="color:#ff9f1a"> Docker Network Commands </span>

- Here are some useful Docker network commands that can help you manage Docker networks:


- 1. **docker network ls**: List all Docker networks on your system.
   ```bash
   docker network ls
   ```
  ![img_2.png](img_2.png)
- 2. **docker network create**: Create a new Docker network.
   ```bash
   docker network create network_name
   ```
  - Previous we see all the types of docker networks are called drivers
  - To create a bridge network specifically, you can use:
  - **-d** refers **Driver**
  ```bash
  docker network create network_name -d bridge
  ```
    ![img_3.png](img_3.png)


- 3. **docker network inspect**: Display detailed information about a specific Docker network.
    ```bash
   docker network inspect network_name
    ```
- 4. **docker network rm**: Remove a Docker network.
   ```bash
   docker network rm network_name
   ```
- 5. **docker network connect**: Connect a container to a Docker network.
   ```bash
    docker network connect network_name container_id
   ```
- 6. **docker network disconnect**: Disconnect a container from a Docker network.
   ```bash
   docker network disconnect network_name container_id
   ```
  

# <span style="color:#ff3f34"> Docker Volume </span>

- Docker volumes are a way to persist data generated by and used by Docker containers.
- Volumes are stored outside the container's filesystem, allowing data to persist even when the container is deleted or recreated.
- Volumes can be shared between multiple containers, making them useful for scenarios where data needs to be accessed by different containers.


### Types of Docker Volumes

- 1. **Named Volumes**: 
   - Created and managed by Docker.
   - Can be easily referenced by name when creating or running containers.
   - Example: `docker volume create my_volume`

- 2. **Bind Mounts**:
   - Maps a directory or file from the host machine to a container.
   - Changes made to the files in the bind mount are reflected in both the host and the container.
   - Example: `docker run -v /host/path:/container/path image_name`


# <span style="color:#ff6f61"> Docker Volume Commands </span>

- Here are some useful Docker volume commands that can help you manage Docker volumes:

- 1. **docker volume ls**: List all Docker volumes on your system.
   ```bash
   docker volume ls
   ```
- 2. **docker volume create**: Create a new Docker volume.
   ```bash
   docker volume create volume_name
   ```
  - 3. **docker volume inspect**: Display detailed information about a specific Docker volume.
     ```bash  
    
    docker volume inspect volume_name
      ```  
    
  - 4. **docker volume rm**: Remove a Docker volume.
   ```bash
   docker volume rm volume_name
   ```
  - 5. **docker run -v**: Create and mount a volume when running a container.
     ```bash
     docker run -v volume_name:/container/path image_name
     ```

  - 6. **docker run -v (bind mount)**: Create and mount a bind mount when running a container.
          ```bash
          docker run -v /host/path:/container/path image_name
          ```
       

# <span style="color:#f79f1b"> Docker Compose </span>

- <span style="color:#912">**Instasudo apt-get install docker-compose-v2ll compose in docker terminal :**  `docker compose version
` </span>

- Docker Compose is a tool for defining and running multi-container Docker applications.
- With Docker Compose, you can use a YAML file to configure your application's services, networks, and volumes.
- Then, with a single command, you can create and start all the services defined in the configuration file.



- **Extension of the Compose file :** `.yml` or `.yaml`

### Key Features of Docker Compose

- 1. **Multi-Container Applications**: Define and run applications that consist of multiple interconnected containers.
- 2. **Service Definition**: Specify the services that make up your application, including their images, ports, volumes, and environment variables.
- 3. **Networking**: Automatically create a network for your services to communicate with each other.
- 4. **Volume Management**: Define and manage data volumes for persistent storage.
- 5. **Scaling**: Easily scale services up or down with a single command.
- 6. **Environment Configuration**: Use environment variables to customize service configurations.


### Example Docker Compose File

> Command to create a docker compose file : `touch docker-compose.yml` 

```yaml
version: '3'
services:
  web:
    image: my-web-app
    ports: 
      - "8080:80"
    volumes:
      - ./web-data:/var/www/html
    environment: 
      - ENV=production
    healthcheck:
      test: ""
      interval: 30s
      timeout: 22s
      retries: 3
  
  db:
    image: mysql:5.7
    volumes:
      - db-data:/var/lib/mysql
    environment:
      - MYSQL_ROOT_PASSWORD=rootpassword  
volumes:
  db-data:
```

### Explaining the docker compose file :

- **version**: Specifies the version of the Docker Compose file format. 
- **services**: Defines the services that make up your application.
  - **web**: A service named "web" that uses the "my-web-app" image.
    - **ports**: Maps port 80 in the container to port 8080 on the host machine.
    - **volumes**: Mounts the local directory `./web-data` to `/var/www/html` in the container.
    - **environment**: Sets an environment variable `ENV` to `production`.
    - **healthcheck**: Configures a health check for the service.
  - **db**: A service named "db" that uses the MySQL 5.7 image.
    - **volumes**: Mounts a named volume `db-data` to `/var/lib/mysql` in the container for data persistence.
    - **environment**: Sets the MySQL root password using an environment variable.
- **volumes**: Defines named volumes that can be shared between services. In this case, `db-data` is defined for the database service.
- This Docker Compose file sets up a simple web application with a web server and a MySQL database, including port mapping, volume mounting, environment variables, and a health check for the web service.


# <span style="color:#3bfb2b"> How to Run Docker Compose File </span>

- To run a Docker Compose file, follow these steps:
  1. Make sure you have Docker and Docker Compose installed on your machine.
  2. Create a `docker-compose.yml` file in your project directory and add your service definitions to it.
  3. Open a terminal and navigate to the directory containing the `docker-compose.yml` file.
  4. Run the following command to start the services defined in the Docker Compose file:
     ```bash
     docker compose up
     ```
     - This command will pull the necessary images (if not already available locally), create the containers, and start them.
     - If you want to run the containers in detached mode (in the background), you can use the `-d` flag:
     ```bash
     docker compose up -d
     ```
  5. To stop the services, you can use the following command:
     ```bash
     docker compose down
     ```
     - This command will stop and remove the containers, networks, and volumes created by `docker compose up`.
  - That's it! You have successfully run a Docker Compose file to manage your multi-container application.


# <span style="color:#37b8cc"> Docker Registry(Hub)</span>

- We simply push images to docker hub or pull images from docker hub
- A Docker registry is a centralized repository where Docker images are stored, managed, and distributed.
- It allows users to share and distribute Docker images, making it easier to deploy applications across different environments.
- Docker registries can be public or private.

![img_4.png](img_4.png)

# <span style="color:#ff6f61"> Docker Registry Commands </span>

- Here are some useful Docker registry commands that can help you manage Docker images in a registry:
- 1. **docker login**: Log in to a Docker registry (e.g., Docker Hub).
   ```bash
   docker login
   ```
- 2. **docker logout**: Log out from a Docker registry.
   ```bash
   docker logout
   ```
- 3. **docker pull**: Download a Docker image from a registry.
  ```bash  
    docker pull image_name:tag
     ```    
- 4. **docker push**: Upload a Docker image to a registry.
   ```bash
      docker push image_name:tag
     ```
- 5. **docker tag**: Tag a Docker image with a new name or version before pushing it to a registry.
   ```bash
     docker tag source_image:tag target_image:tag
     ``` 
- 6. **docker search**: Search for Docker images in a registry (e.g., Docker Hub).
  ```bash  
    docker search image_name
  ```  
    


# <span style="color:#ff3f34">Docker Multi-Stage Build </span>

- <span style="color:yellow" >It is useful to optimize the size of docker images. </span>
- A Docker multi-stage build is a technique that allows you to use multiple `FROM` statements in a single Dockerfile to create smaller, more efficient Docker images.
- By using multi-stage builds, you can separate the build environment from the runtime environment, resulting in smaller images that only contain the necessary components to run the application.
- This approach helps reduce the size of the final image, improves security by minimizing the attack surface, and simplifies the build process.
- Each stage can use a different base image, and you can copy artifacts from one stage to another using the `COPY --from` instruction.
- This technique is particularly useful for applications that require a build process, such as compiling code or installing dependencies, before they can be run.
- Here's an example of a Dockerfile that uses multi-stage builds:

```dockerfile
# Stage 1: Build stage
FROM maven:3.8.4-openjdk-11 AS build
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN mvn clean package -DskipTests 
# Stage 2: Runtime stage
FROM openjdk:11-jre-slim
WORKDIR /app
COPY --from=build /app/target/my-app.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
```

- In this example, the first stage uses a Maven image to build a Java application, while the second stage uses a lightweight OpenJDK image to run the application.
- The final image only contains the necessary runtime components, resulting in a smaller and more efficient Docker image.

- To build and run the multi-stage Dockerfile, you can use the same commands as before:

```bash
docker build -t my-multi-stage-app .
docker run -p 8080:8080 my-multi-stage-app
```
- That's it! You have successfully created a Docker multi-stage build to optimize your Docker images.


# <span style="color:#ff9f1a"> Dockers Logs and Monitoring </span>

- Docker provides several commands and tools to help you monitor and view logs from your Docker containers.
- Here are some useful commands and techniques for monitoring Docker containers and viewing their logs:
- 1. **docker logs**: View the logs of a specific Docker container.
   ```bash
   docker logs container_id
   ```
- 2. **docker stats**: Display real-time resource usage statistics for running Docker containers.
   ```bash
   docker stats
   ```
- 3. **docker top**: Display the running processes inside a Docker container.
   ```bash
   docker top container_id
   ```
- 4. **docker inspect**: Display detailed information about a Docker container, including its configuration and state.
   ```bash
   docker inspect container_id
   ```
- 5. **docker events**: Monitor real-time events from the Docker daemon, such as container start, stop, and die events.
   ```bash
   docker events
   ```
- 6. **Logs in file**: You can also configure Docker to write container logs to a file on the host machine by using the `--log-driver` and `--log-opt` options when running a container.
   ```bash
    nohup docker attach container_id &
    ```
       cat nohup.out 
  